message CaffeGenDef {
	required string name = 1;

	// by default the following is 1, which means just the recs of one sentence are searched in the first access  
	// which still allows further criteria by using Data Translate - but not using the first search
	optional int32 NumSentenceRecsToSearch = 2; 
	enum AccessType {
		ACCESS_TYPE_DEP = 1;
		ACCESS_TYPE_WORD = 2;
	}

	message DataAccess {
		required string var_name = 1; // what will be stored is the RDID
		required AccessType access_type = 2; 
		optional string dep_type_to_match = 3; // the name of the dep type to match. Not the integer code
		optional string POS_to_match = 4;
		optional int32 var_idx = 5; // place holder for run_time insertion. Index of var table
		optional int32 max_srec_beyond = 11; // Dep/Word will match in sentence recs beyond the first up till this val. Default 0 only the first sentence
		optional int32 min_srec_beyond = 12; // Minimum number of sentences beyond the first for this to match. Default 0, any up to max 
		// required int32 ExecOrderPos = 7; // allows creation of a specific order where 
	}

	repeated DataAccess access_fields = 3;

	enum MatchType  {
		mtDEP_RDID = 1;
		mtDEP_GOV_RWID = 2;
		mtDEP_DEP_RWID = 3;
		mtWORD_RWID = 4;
		mtWORD_CORE = 5;
		mtWORD_WORD = 6;
		mtWORD_POS = 7;
	}

	message DataFilterOneSide {
		required string var_name_src = 1;
		required MatchType mt = 2;
		optional int32 var_src_idx = 3; // place holder for run_time insertion. Index of var table
	};

	enum FilterMatchType {
		fmtEqual = 1;
		fmtClose = 2;
	};

	message DataFilter {
		optional FilterMatchType fmt = 1; // dafault fmtEqual
		required DataFilterOneSide left_side = 2;
		required DataFilterOneSide right_side = 3;
	};

	repeated DataFilter data_filters = 4;
	
	enum WordDataType {
		wdtWORD = 1;
		wdtPOS = 2;
		wdtCORE = 3;
	}

	enum DataTranslateType {
		dttRWID_TO_WORD = 1;
		dttRWID_TO_COREF = 2;
		dttRWID_TO_RDID = 3;
		dttRDID_TO_DEP_NAME = 4;
		dttRDID_TO_GOV_RWID = 5;
		dttRDID_TO_DEP_RWID = 6;
	}
	message DataTranslate {
		required DataTranslateType translate_type = 1;
		required string var_name = 2;
		required string match_name = 4;
		optional WordDataType field_type = 6; // used when translating to WORD to specify which, i.e. WORD, POS etc.
	}
	repeated DataTranslate data_translates = 5;

	enum VarExtractType {
		vetPOS = 1;
		vetWordCore = 2;
		vetWord = 3;
		vetDepName = 4;
		vetDummy = 5;
		vetNumDepGovs = 6;
	}

	message NetValue {
		required bool b_input = 1; // else output
		required string var_name = 2; // var name for this value
		required string var_name_src = 3; // name of entry in var table to extract data from
		required VarExtractType vet = 4;
		required string vec_table_name = 5; // may be an integer instead or in addition to this
		optional int32 var_src_idx = 6; // place holder for run_time insertion. Index of var table
		optional int32 vec_table_idx = 7; // place holder for run_time insertion. Index of vec table
		optional bool b_can_replace = 8;
		optional int32 max_instances = 9;
		// 0 - 1 propability of replacing another record if the max_instances has been exceeded
		// needed for making sure all source files participate in high usage examples and not 
		// only first and last
		optional float replace_prob = 10; 
	}

	repeated NetValue net_values = 6;

	required string files_core_dir = 8;
	required string test_list_file_name = 9;
	required string train_list_file_name = 10;
	enum NetEndType {
		END_VALID = 1; // end will be yes or no
		END_ONE_HOT = 2; // output of hd5 will be an integer but matched in net by as many nodes as the highest integer
		END_MULTI_HOT = 3; // output in hd5 file looks the same as net output layer
	}
	required NetEndType net_end_type = 11;
	required string proto_file_name = 12;
	required string model_file_name = 13;
	required string config_file_name = 14;
	optional int32 num_accuracy_candidates = 15; // passed right on to caffe's config. Only relevant for some EndTypes
	required string netgen_output_file_name = 18; // stores data such as number of layers, number of nodes, which is the output layer, generated by netgen

}



